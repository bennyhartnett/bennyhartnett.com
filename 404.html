<!--
  WebGL Kinetic Typography (Three.js + GSAP)
  - Loads Google Font (Muli 600)
  - Renders 4 titles (404 / ERROR / NOT / FOUND) as sliced planes
  - Animates each slice via a RawShaderMaterial uniform (tween.x)

  Dependencies loaded defensively (script onload + fallback CDN).
  Only starts after THREE/gsap/WebFont are confirmed present.
-->
<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <meta name="color-scheme" content="dark" />
  <title>404 - Page Not Found</title>

  <style>
    * { margin: 0; padding: 0; }

    html {
      background-color: #000;
      font-family: 'Muli', sans-serif;
      color: #fff;
      overflow: hidden;
    }

    #Canvas {
      display: block;
      position: absolute;
      top: calc(50% - 270px);
      left: calc(50% - 480px);
      width: 960px;
      height: 540px;
      z-index: 1;
    }

    .home-link {
      position: fixed;
      bottom: 2rem;
      left: 50%;
      transform: translateX(-50%);
      z-index: 10;
      color: rgba(255, 255, 255, 0.5);
      text-decoration: none;
      font-family: 'Muli', sans-serif;
      font-size: 0.9rem;
      letter-spacing: 0.1em;
      text-transform: uppercase;
      transition: color 0.3s ease;
    }

    .home-link:hover {
      color: #fff;
    }
  </style>
</head>
<body>
  <canvas id="Canvas"></canvas>
  <a href="https://bennyhartnett.com" class="home-link">Go Home</a>

  <script>
    const statusEl = document.getElementById('status');
    function setStatus(msg) {
      if (statusEl) statusEl.textContent = msg;
    }

    function loadScript({ src, id }) {
      return new Promise((resolve, reject) => {
        if (id && document.getElementById(id)) {
          resolve();
          return;
        }
        const s = document.createElement('script');
        if (id) s.id = id;
        s.src = src;
        s.async = true;
        s.onload = () => resolve();
        s.onerror = () => reject(new Error(`Failed to load script: ${src}`));
        document.head.appendChild(s);
      });
    }

    async function loadWithFallback(label, primary, fallback, id) {
      try {
        setStatus(`Loading ${label}…`);
        await loadScript({ src: primary, id });
      } catch (e1) {
        console.warn(e1);
        setStatus(`Retrying ${label} (fallback)…`);
        await loadScript({ src: fallback, id: id ? `${id}-fallback` : undefined });
      }
    }

    function assert(condition, message) {
      if (!condition) throw new Error(message);
    }

    function runSmokeTests() {
      assert(typeof window.THREE !== 'undefined', 'THREE is not defined (Three.js not loaded).');
      assert(typeof window.gsap !== 'undefined', 'gsap is not defined (GSAP not loaded).');
      assert(typeof window.WebFont !== 'undefined', 'WebFont is not defined (webfontloader not loaded).');
      assert(typeof THREE.WebGLRenderer === 'function', 'Three.js loaded but WebGLRenderer missing.');
      assert(typeof gsap.timeline === 'function', 'GSAP loaded but timeline() missing.');
      assert(typeof WebFont.load === 'function', 'WebFont loaded but load() missing.');
    }

    // --- Shaders ---

    const vertexShader = `
    uniform mat4 modelViewMatrix;
    uniform mat4 projectionMatrix;
    uniform float time;
    uniform float index;
    uniform float divisions;
    uniform float tOffsetX;
    uniform vec4 tween;
    attribute vec3 position;
    attribute vec2 uv;
    varying vec2 vUv;

    mat2 scale2D(vec2 scale) {
      return mat2(scale.x, 0.0, 0.0, scale.y);
    }

    void main() {
      vUv = uv;
      vec3 pos = position;

      float scaleX = tween.x;
      pos.x += tOffsetX;
      pos.xy *= scale2D(vec2(scaleX, 1.0));
      pos.x -= tOffsetX;

      gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);
    }
    `;

    const fragmentShader = `
    precision highp float;

    uniform sampler2D texture;
    uniform float time;
    uniform float index;
    uniform float divisions;
    uniform vec4 tween;
    varying vec2 vUv;

    void main() {
      vec2 uv = vUv;
      float startV = index * (1.0 / divisions);
      vec2 tuv = vec2(uv.x, startV + uv.y * (1.0 / divisions));

      vec4 color = texture2D(texture, tuv);
      gl_FragColor = color;
    }
    `;

    // --- General settings ---
    const width = 960;
    const height = 540;
    const aspectRatio = width / height;
    const dpr = Math.min(window.devicePixelRatio || 1, 2);
    const sceneWidth = 2;
    const sceneHeight = sceneWidth / aspectRatio;
    let scene, camera, renderer;

    // --- Title settings ---
    const titleWidth = 2.0;
    const titleHeight = 0.5;
    const numDivisions = 40;
    const titleMeshes = [];
    let numMeshes = 0;

    // --- Text titles ---
    const texts = ['404', 'ERROR', 'NOT', 'FOUND'];

    // --- Animation settings ---
    const tweens = [];

    function createCanvas() {
      scene = new THREE.Scene();

      camera = new THREE.OrthographicCamera(
        -sceneWidth / 2,
        sceneWidth / 2,
        sceneHeight / 2,
        -sceneHeight / 2,
        0.01,
        1000
      );
      camera.position.set(0, 0, 1);

      renderer = new THREE.WebGLRenderer({
        antialias: true,
        alpha: true,
        canvas: document.getElementById('Canvas')
      });
      renderer.setSize(width, height);
      renderer.setPixelRatio(dpr);

      texts.forEach((text, i) => {
        const texture = createFontTexture({ width: 1024, height: 256, fontSize: 230, text });
        tweens.push([]);
        createTitle({ texture, tweens: tweens[i] });
      });

      numMeshes = titleMeshes.length;
      animateTitle();
    }

    function createFontTexture(options) {
      const canvas = document.createElement('canvas');
      const w = options.width * dpr;
      const h = options.height * dpr;
      canvas.width = w;
      canvas.height = h;

      const ctx = canvas.getContext('2d');
      ctx.font = `600 ${options.fontSize * dpr}px 'Muli'`;
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.fillStyle = '#fff';
      ctx.fillText(options.text, w / 2, h / 2 + 25);

      const texture = new THREE.CanvasTexture(canvas);
      texture.minFilter = THREE.LinearFilter;
      texture.magFilter = THREE.LinearFilter;
      texture.format = THREE.RGBAFormat;
      texture.needsUpdate = false;
      return texture;
    }

    function createTitle(params) {
      for (let i = 0; i < numDivisions; i++) {
        const dividedHeight = titleHeight / numDivisions;
        const geometry = new THREE.PlaneGeometry(titleWidth, dividedHeight);

        const material = new THREE.RawShaderMaterial({
          uniforms: {
            texture: { value: params.texture },
            time: { value: 0 },
            index: { value: i },
            divisions: { value: numDivisions },
            tOffsetX: { value: -1.0 },
            tween: { value: new THREE.Vector4(0, 0, 1, 1) }
          },
          vertexShader,
          fragmentShader,
          transparent: true
        });

        const y = -titleHeight * 0.5 + i * dividedHeight + dividedHeight * 0.5;
        const mesh = new THREE.Mesh(geometry, material);
        mesh.position.y = y;

        scene.add(mesh);
        titleMeshes.push(mesh);
        params.tweens.push(material.uniforms.tween.value);
      }
    }

    function animateTitle() {
      const tl = gsap.timeline({
        repeat: -1,
        defaults: {
          ease: 'power3.inOut',
          duration: 0.8,
          stagger: 0.01
        }
      });

      const setTransformOffset = (titleIndex, value) => {
        const startIndex = titleIndex * numDivisions;
        const endIndex = startIndex + numDivisions;
        for (let i = startIndex; i < endIndex; i++) {
          titleMeshes[i].material.uniforms.tOffsetX.value = value;
        }
      };

      tweens.forEach((tw, i) => {
        const inLabel  = i === 0 ? 'start' : `next${i}`;
        const outLabel = i < tweens.length - 1 ? `next${i + 1}` : undefined;
        tl.to(tw, { x: 1.0, onStart: () => setTransformOffset(i, -1.0) }, inLabel);
        if (outLabel) {
          tl.to(tw, { x: 0.0, onStart: () => setTransformOffset(i, 1.0) }, outLabel);
        } else {
          tl.to(tw, { x: 0.0, onStart: () => setTransformOffset(i, 1.0) });
        }
      });
    }

    function updateCanvas() {
      requestAnimationFrame(updateCanvas);
      const time = performance.now() * 0.001;
      for (let i = 0; i < numMeshes; i++) {
        titleMeshes[i].material.uniforms.time.value = time;
      }
      renderer.render(scene, camera);
    }

    async function boot() {
      try {
        await loadWithFallback(
          'Three.js',
          'https://cdnjs.cloudflare.com/ajax/libs/three.js/r152/three.min.js',
          'https://unpkg.com/three@0.152.2/build/three.min.js',
          'three'
        );
        await loadWithFallback(
          'GSAP',
          'https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.5/gsap.min.js',
          'https://unpkg.com/gsap@3.12.5/dist/gsap.min.js',
          'gsap'
        );
        await loadWithFallback(
          'WebFont Loader',
          'https://cdnjs.cloudflare.com/ajax/libs/webfont/1.6.28/webfontloader.js',
          'https://unpkg.com/webfontloader@1.6.28/webfontloader.js',
          'webfont'
        );

        runSmokeTests();

        setStatus('Loading font…');
        WebFont.load({
          google: { families: ['Muli:600'] },
          classes: false,
          active: () => {
            setStatus('Running…');
            createCanvas();
            updateCanvas();
          },
          inactive: () => {
            console.warn('WebFont inactive; proceeding with fallback font.');
            setStatus('Font failed; running with fallback…');
            createCanvas();
            updateCanvas();
          }
        });
      } catch (err) {
        console.error(err);
        setStatus(`Error: ${err.message}`);
      }
    }

    boot();
  </script>
</body>
</html>
